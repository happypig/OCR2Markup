<!-- Generated by SpecStory -->

<!-- vscode Session 43d0e9e8-658b-436c-a1f9-636b1610c99c (2025-09-23 23:19Z) -->

# Extending functionality in Java applications (2025-09-23 23:19Z)

_**User (2025-09-23 23:20Z)**_

what's the normal approach to extend functionality of java application?

---

_**Assistant (copilot/claude-sonnet-4)**_

There are several standard approaches to extend the functionality of Java applications, depending on the architecture and requirements:

## 1. **Plugin Architecture**
- **OSGi (Open Service Gateway Initiative)**: Dynamic module system for Java
- **Custom Plugin Systems**: Like what you're working with in Oxygen XML Editor
- **Java Platform Module System (JPMS)**: Since Java 9, using modules

## 2. **Extension Points and Interfaces**
- Define extension interfaces that implementations can provide
- Use Service Provider Interface (SPI) pattern
- Dependency Injection frameworks (Spring, Guice)

## 3. **Configuration-Based Extensions**
- External configuration files (XML, JSON, YAML, Properties)
- Annotation-based configuration
- Convention over configuration

## 4. **Scripting Integration**
- Embed scripting engines (JavaScript via Nashorn/GraalVM, Groovy, Python via Jython)
- Your current code uses JavaScript within Java via Nashorn/Rhino

## 5. **Dynamic Class Loading**
- Load JAR files at runtime
- Reflection for dynamic method invocation
- Custom ClassLoaders

## 6. **Event-Driven Architecture**
- Observer pattern
- Event buses (Guava EventBus, Spring Events)
- Message queues

## 7. **Aspect-Oriented Programming (AOP)**
- Cross-cutting concerns (logging, security, transactions)
- AspectJ, Spring AOP

## 8. **External Process Integration**
- REST APIs
- Command-line tool execution
- Inter-process communication

In your case with the Oxygen XML Editor plugin, you're using a **plugin architecture** where:
- The host application (Oxygen) provides extension points
- Your plugin implements specific interfaces (`ViewComponentCustomizer`)
- JavaScript is used as a scripting layer for flexibility
- Configuration is managed through the application's option storage system

This is a common and effective pattern for extending desktop applications while maintaining loose coupling between the core application and extensions.

---

_**User (2025-09-23 23:22Z)**_

what's the difference between Oxygen's plugin architecture with OSGI and JPMS?

---

_**Assistant (copilot/claude-sonnet-4)**_

Looking at your Oxygen XML Editor plugin code, I can explain the key differences between Oxygen's plugin architecture and OSGi/JPMS:

## **Oxygen's Plugin Architecture**

Your current code shows Oxygen uses a **custom plugin framework** with these characteristics:

- **JavaScript-based extensions** with Java interop via Nashorn/Rhino
- **Extension point interfaces** like `ViewComponentCustomizer`
- **Host application provides services** (workspace access, options storage, resource bundles)
- **Simple lifecycle** (`applicationStarted()`, `applicationClosing()`)
- **Static plugin loading** at application startup

````javascript
// Oxygen's approach - JavaScript extending Java application
pluginWorkspaceAccess.addViewComponentCustomizer(new JavaAdapter(
    Packages.ro.sync.exml.workspace.api.standalone.ViewComponentCustomizer, {
        customizeView: function(viewInfo) {
            // Plugin logic here
        }
    }
));
````

## **OSGi (Open Service Gateway Initiative)**

OSGi is a **dynamic module system** with:

- **Dynamic loading/unloading** of bundles at runtime
- **Service registry** for loose coupling between modules
- **Versioning and dependency management**
- **Security and isolation** between bundles
- **Complex lifecycle** (INSTALLED → RESOLVED → STARTING → ACTIVE → STOPPING → UNINSTALLED)

````java
// OSGi approach - Java bundles with manifest
// In MANIFEST.MF:
Bundle-Activator: com.example.MyActivator
Export-Package: com.example.api;version="1.0.0"
Import-Package: org.osgi.framework;version="[1.8,2.0)"

// Java activator class
public class MyActivator implements BundleActivator {
    public void start(BundleContext context) {
        // Register services dynamically
        context.registerService(MyService.class, new MyServiceImpl(), null);
    }
}
````

## **JPMS (Java Platform Module System)**

JPMS provides **compile-time modularity** with:

- **Module declarations** in `module-info.java`
- **Compile-time dependency checking**
- **Strong encapsulation** - only exported packages are accessible
- **Static module graph** resolved at startup
- **No dynamic loading/unloading**

````java
// JPMS approach - module-info.java
module com.example.plugin {
    requires java.desktop;
    requires oxygen.api;
    
    exports com.example.plugin.api;
    provides com.example.plugin.api.PluginService 
        with com.example.plugin.impl.PluginServiceImpl;
}
````

## **Key Differences Summary**

| Aspect | Oxygen Plugin | OSGi | JPMS |
|--------|---------------|------|------|
| **Language** | JavaScript + Java | Java | Java |
| **Loading** | Static at startup | Dynamic runtime | Static at startup |
| **Lifecycle** | Simple (start/stop) | Complex (6 states) | Simple (load/unload) |
| **Versioning** | Host application managed | Built-in version ranges | Basic version support |
| **Isolation** | Shared classloader | Bundle classloaders | Module system |
| **Services** | Extension points | Service registry | ServiceLoader |
| **Hot deployment** | No | Yes | No |

## **Why Oxygen Uses Custom Architecture**

1. **Simplicity** - Easier for plugin developers
2. **JavaScript flexibility** - Dynamic scripting capabilities
3. **Desktop application focus** - No need for complex dynamic loading
4. **Backward compatibility** - Stable API for existing plugins
5. **Performance** - Less overhead than full OSGi framework

Your plugin demonstrates this well - it's straightforward JavaScript that extends Java functionality without complex module management or dynamic lifecycle concerns.

---

_**User (2025-09-23 23:26Z)**_

how to learn Oxygen's Plugin Architecture fast in order to write custom functions?

---

_**Assistant (copilot/claude-sonnet-4)**_

To learn Oxygen XML Editor's Plugin Architecture quickly for writing custom functions, here's a structured approach based on your existing code:

## **1. Start with Official Documentation**

- **Oxygen SDK Documentation**: Start with the [official plugin development guide](https://www.oxygenxml.com/doc/ug-editor/topics/sdk-introduction.html)
- **API JavaDocs**: Essential for understanding available classes and methods
- **Sample Plugins**: Download official example plugins from Oxygen's website

## **2. Understand Core Concepts from Your Code**

Your `dila-ai-markup.js` demonstrates key patterns:

### **Plugin Entry Points**
````javascript
// Plugin lifecycle callbacks
function applicationStarted(pluginWorkspaceAccess) {
    // Initialize plugin when Oxygen starts
}

function applicationClosing() {
    // Cleanup when Oxygen closes
}
````

### **Key Services Your Code Uses**
````javascript
// Essential services available through pluginWorkspaceAccess
var resources = pluginWorkspaceAccess.getResourceBundle(); // i18n
var optionStorage = pluginWorkspaceAccess.getOptionsStorage(); // preferences
var editorAccess = pluginWorkspaceAccess.getCurrentEditorAccess(); // document manipulation
````

## **3. Practice with Incremental Extensions**

Based on your commented-out options code, try these learning exercises:

### **Exercise 1: Simple Options Dialog**
Uncomment and fix your options panel code to understand how configuration works:

````javascript
function importOptionsSpace(optionStorage, parseModelField, detectModelField, apiKeyField) {
    var parseModel = optionStorage.getOption("dila.dama.ft.parse.model", "gemini-1.5-flash");
    var detectModel = optionStorage.getOption("dila.dama.ft.detect.model", "gemini-1.5-pro");
    var apiKey = optionStorage.getSecretOption("dila.dama.api.key", "");

    parseModelField.setText(parseModel);
    detectModelField.setText(detectModel);
    apiKeyField.setText(apiKey);
}

function saveOptionsSpace(optionStorage, parseModelField, detectModelField, apiKeyField) {
    try {
        var parseModel = parseModelField.getText();
        var detectModel = detectModelField.getText();
        var apiKey = apiKeyField.getText();

        if (optionStorage == null) {
            logDebug("No options storage available to save options.");
            return false;
        }

        optionStorage.setOption("dila.dama.ft.parse.model", parseModel);
        optionStorage.setOption("dila.dama.ft.detect.model", detectModel);
        optionStorage.setSecretOption("dila.dama.api.key", apiKey);

        logDebug("Options saved to optionStorage.");
        return true;
    } catch (e) {
        logDebug("Error saving options (saveOptionsSpace): " + e);
        return false;
    }
}
````

### **Exercise 2: Document Manipulation**
Study your replace button code to understand text editing:

````javascript
// Key pattern for document editing
var editorAccess = pluginWorkspaceAccess.getCurrentEditorAccess();
var pageAccess = editorAccess.getCurrentPage();
if (pageAccess instanceof Packages.ro.sync.exml.workspace.api.editor.page.text.WSTextEditorPage) {
    pageAccess.beginCompoundUndoableEdit(); // For undo support
    try {
        // Perform edits here
        pageAccess.deleteSelection();
        pageAccess.getDocument().insertString(position, text, null);
    } finally {
        pageAccess.endCompoundUndoableEdit();
    }
}
````

## **4. Essential Extension Points to Master**

### **ViewComponentCustomizer** (Your Current Approach)
````javascript
pluginWorkspaceAccess.addViewComponentCustomizer(new JavaAdapter(
    Packages.ro.sync.exml.workspace.api.standalone.ViewComponentCustomizer, {
        customizeView: function(viewInfo) {
            // Create custom UI panels
        }
    }
));
````

### **Other Key Extension Points**
- **WorkspaceAccessPluginExtension**: Main plugin interface
- **OptionPagePluginExtension**: For preferences dialogs
- **AuthorOperationWithResult**: Custom editing operations
- **URLStreamHandlerPluginExtension**: Custom protocols

## **5. Fast Learning Strategy**

### **Week 1: Foundation**
1. Set up debugging (you already have `logDebug()`)
2. Create a minimal "Hello World" plugin
3. Understand the plugin.xml descriptor file
4. Learn about resource bundles for i18n

### **Week 2: UI Development**
1. Master Swing components within Oxygen (your code uses JPanel, JMenuBar, etc.)
2. Understand Oxygen's layout patterns
3. Practice with action listeners and event handling

### **Week 3: Editor Integration**
1. Learn document access patterns
2. Practice text selection and replacement
3. Understand undo/redo integration
4. Study XPath and XML manipulation if needed

### **Week 4: Advanced Features**
1. Network operations (like your LLM API calls)
2. Threading (your `networkThread` pattern)
3. Options persistence
4. Error handling and user feedback

## **6. Debug and Learn Pattern**

Your existing debug infrastructure is excellent:

````javascript
// Use this pattern to understand Oxygen's internals
logDebug("Object type: " + someObject.getClass().getName());
logDebug("Available methods: " + Object.getOwnPropertyNames(someObject));
````

## **7. Resources for Rapid Learning**

1. **Oxygen Community Forum**: Active developer community
2. **GitHub**: Search for open-source Oxygen plugins
3. **Oxygen's Sample Plugins**: Download and study official examples
4. **JavaScript-Java Bridge**: Learn Nashorn/Rhino patterns for Java interop

## **8. Common Pitfalls to Avoid**

- **Threading**: Always use `SwingUtilities.invokeLater()` for UI updates (you're doing this correctly)
- **Memory Leaks**: Properly dispose of listeners and resources
- **API Version Compatibility**: Check Oxygen version requirements
- **Error Handling**: Wrap Java calls in try-catch blocks

Your current code shows good practices - build on this foundation and you'll master Oxygen plugin development quickly!

---

_**User (2025-09-24 03:00Z)**_

how to get preferencePageKey

---

_**Assistant (copilot/claude-sonnet-4)**_

In Oxygen XML Editor's plugin architecture, the `preferencePageKey` is used to identify and register custom preference pages in the Options dialog. Here's how to work with it:

## **1. Understanding Preference Page Keys**

The `preferencePageKey` is a unique identifier string that:
- Registers your custom options page with Oxygen's preferences system
- Links menu actions to specific preference pages
- Organizes preferences in a hierarchical structure

## **2. Common Preference Page Key Patterns**

````javascript
// Standard patterns for preference page keys:

// Plugin-specific preferences
var preferencePageKey = "dila.ai.markup.preferences";

// Hierarchical organization (creates tree structure)
var mainPageKey = "dila.ai.markup";
var subPageKey = "dila.ai.markup.models";
var advancedPageKey = "dila.ai.markup.advanced";

// Following Oxygen's conventions
var oxygenStyleKey = "oxygen.dila.ai.markup.settings";
````

## **3. Registering Custom Preference Pages**

To create custom preference pages, you need to implement `OptionPagePluginExtension`:

````javascript
function applicationStarted(pluginWorkspaceAccess) {
    // ...existing code...

    // Register a custom preference page
    pluginWorkspaceAccess.addOptionPagePluginExtension(new JavaAdapter(
        Packages.ro.sync.exml.workspace.api.PluginWorkspace.OptionPagePluginExtension, {
            
            getOptionPageKey: function() {
                return "dila.ai.markup.preferences"; // Your preference page key
            },
            
            getOptionPageTitle: function() {
                return i18nFn("preferences.page.title"); // "DILA AI Markup Settings"
            },
            
            getOptionPageParent: function() {
                return null; // Top level, or return parent key for hierarchy
            },
            
            createOptionPage: function() {
                // Create and return your options panel
                return createOptionsPanel();
            }
        }
    ));

    // Function to create your options panel
    function createOptionsPanel() {
        var JPanel = Packages.javax.swing.JPanel;
        var GridBagLayout = Packages.java.awt.GridBagLayout;
        var GridBagConstraints = Packages.java.awt.GridBagConstraints;
        var JLabel = Packages.javax.swing.JLabel;
        var JTextField = Packages.javax.swing.JTextField;
        var JPasswordField = Packages.javax.swing.JPasswordField;
        var Insets = Packages.java.awt.Insets;

        var optionsPanel = new JPanel(new GridBagLayout());
        var gbc = new GridBagConstraints();
        gbc.insets = new Insets(5, 5, 5, 5);
        gbc.anchor = GridBagConstraints.WEST;

        // Parse Model Field
        gbc.gridx = 0; gbc.gridy = 0;
        optionsPanel.add(new JLabel(i18nFn("ft.parse.model.label")), gbc);
        gbc.gridx = 1; gbc.fill = GridBagConstraints.HORIZONTAL; gbc.weightx = 1.0;
        var parseModelField = new JTextField(20);
        optionsPanel.add(parseModelField, gbc);

        // Detect Model Field
        gbc.gridx = 0; gbc.gridy = 1; gbc.fill = GridBagConstraints.NONE; gbc.weightx = 0;
        optionsPanel.add(new JLabel(i18nFn("ft.detect.model.label")), gbc);
        gbc.gridx = 1; gbc.fill = GridBagConstraints.HORIZONTAL; gbc.weightx = 1.0;
        var detectModelField = new JTextField(20);
        optionsPanel.add(detectModelField, gbc);

        // API Key Field
        gbc.gridx = 0; gbc.gridy = 2; gbc.fill = GridBagConstraints.NONE; gbc.weightx = 0;
        optionsPanel.add(new JLabel(i18nFn("api.key.label")), gbc);
        gbc.gridx = 1; gbc.fill = GridBagConstraints.HORIZONTAL; gbc.weightx = 1.0;
        var apiKeyField = new JPasswordField(40);
        optionsPanel.add(apiKeyField, gbc);

        // Load existing values
        importOptionsSpace(optionStorage, parseModelField, detectModelField, apiKeyField);

        // Store fields for saving
        optionsPanel.parseModelField = parseModelField;
        optionsPanel.detectModelField = detectModelField;
        optionsPanel.apiKeyField = apiKeyField;

        return optionsPanel;
    }

    // ...existing code...
}
````

## **4. Opening Specific Preference Pages**

You can open specific preference pages programmatically:

````javascript
// ...existing code...

// Modify your preferences menu action
menuItemOption.addActionListener(function() {
    logDebug("Settings option triggered");
    buttonPanel.setVisible(false);

    // Open general options dialog
    pluginWorkspaceAccess.showOptionsDialog();
    
    // Or open specific preference page (if supported)
    // pluginWorkspaceAccess.showOptionsDialog("dila.ai.markup.preferences");
});

// ...existing code...
````

## **5. Finding Existing Preference Page Keys**

To discover existing preference page keys in Oxygen:

````javascript
// ...existing code...

// Debug existing option keys (add this to your applicationStarted function)
if (optionStorage != null) {
    // Look for existing Oxygen preference patterns
    var existingKeys = [
        "oxygen.positron.plugin.actions.folder",
        "oxygen.positron.plugin.direct.connector.param.custom-ai-service.ai_key_param",
        "oxygen.positron.plugin.direct.connector.param.custom-ai-service.base_URL_param",
        "builder.xpath.type.v14"
    ];
    
    existingKeys.forEach(function(key) {
        var value = optionStorage.getOption(key, "");
        if (value.length > 0) {
            logDebug("Found option key: " + key + " = " + value);
        }
    });
}

// ...existing code...
````

## **6. Best Practices for Preference Page Keys**

1. **Use reverse domain naming**: `com.yourcompany.plugin.preferences`
2. **Be consistent**: Use the same prefix across all your plugin's keys
3. **Create hierarchy**: Use dots to organize related settings
4. **Avoid conflicts**: Don't use `oxygen.*` or `ro.sync.*` prefixes

## **7. Complete Example Pattern**

````javascript
// Your preference page key should be:
var PREFERENCE_PAGE_KEY = "dila.ai.markup.preferences";

// Your option storage keys should follow the same pattern:
var OPTION_KEYS = {
    PARSE_MODEL: "dila.ai.markup.ft.parse.model",
    DETECT_MODEL: "dila.ai.markup.ft.detect.model", 
    API_KEY: "dila.ai.markup.api.key"
};
````

This approach integrates your plugin's settings properly with Oxygen's preference system, making them accessible through the standard Options dialog while maintaining a clean separation from other plugins' settings.

---

_**User (2025-09-24 03:13Z)**_

where is the option page key defined?

---

_**Assistant (copilot/claude-sonnet-4)**_

Looking at your `DAMAWorkspaceAccessOptionPagePluginExtension.java` file, I can see that **the option page key is not explicitly defined in this class**.

In Oxygen's plugin architecture, the option page key is typically defined in one of these locations:

## **1. Plugin Descriptor File (plugin.xml)**

The option page key is usually registered in your `plugin.xml` file:

````xml
<plugin>
    <extension type="OptionPage" class="dila.workspace.DAMAWorkspaceAccessOptionPagePluginExtension">
        <optionPageKey>dila.dama.options</optionPageKey>
        <parentPageKey>plugins</parentPageKey> <!-- Optional parent -->
    </extension>
</plugin>
````

## **2. Override getKey() Method**

Alternatively, you can define it by overriding the `getKey()` method in your extension class:

````java
// ...existing code...
public class DAMAWorkspaceAccessOptionPagePluginExtension extends OptionPagePluginExtension {
  
  /**
   * The option page key for this preferences page.
   */
  public static final String OPTION_PAGE_KEY = "dila.dama.options";

  // ...existing code...

  /**
   * @see ro.sync.exml.plugin.option.OptionPagePluginExtension#getKey()
   */
  @Override
  public String getKey() {
    return OPTION_PAGE_KEY;
  }

  // ...existing code...
}
````

## **3. Current Issue in Your Code**

There's also a syntax error in your `init()` method that needs fixing:

````java
// ...existing code...
String apiKey = pluginWorkspace.getOptionsStorage().getOption(
    KEY_DILA_DAMA_API_KEY,
    null);
    null); // Remove this duplicate line
// ...existing code...
````

## **4. Complete Fix**

Here's how to properly define the option page key:

````java
package dila.workspace;

// ...existing imports...

/**
 * Plugin option page extension Custom Workspace Access Plugin Extension.
 */
public class DAMAWorkspaceAccessOptionPagePluginExtension extends OptionPagePluginExtension {

  /**
   * The option page key for this preferences page.
   */
  public static final String OPTION_PAGE_KEY = "dila.dama.options";

  /**
   * The option key describing the ft parse model.
   */
  public static final String KEY_DILA_DAMA_FT_PARSE_MODEL = "dila.dama.ft.parse.model";

  /**
   * The option key describing the ft detect model.
   */
  public static final String KEY_DILA_DAMA_FT_DETECT_MODEL = "dila.dama.ft.detect.model";

  /**
   * The option key describing the API key.
   */
  public static final String KEY_DILA_DAMA_API_KEY = "dila.dama.api.key";

  // ...existing fields...

  /**
   * @see ro.sync.exml.plugin.option.OptionPagePluginExtension#getKey()
   */
  @Override
  public String getKey() {
    return OPTION_PAGE_KEY;
  }

  // ...existing code...

  @Override
  public JComponent init(final PluginWorkspace pluginWorkspace) {
    // ...existing code...

    String apiKey = pluginWorkspace.getOptionsStorage().getOption(
        KEY_DILA_DAMA_API_KEY,
        null);
    // Remove the duplicate null); line

    // ...existing code...
  }

  // ...existing code...
}
````

The option page key (`dila.dama.options`) is what you would use in your JavaScript code when calling `pluginWorkspaceAccess.showOptionsDialog("dila.dama.options")` to open this specific preference page directly.

---

_**User (2025-09-24 05:43Z)**_

@workspace /explain 

---

_**Assistant (copilot/claude-sonnet-4)**_

The code snippet `version="${project.nosnapshot.version}"` is a **Maven property reference** used within an XML configuration file, specifically in a `plugin.xml` file.

This line demonstrates Maven's **property substitution mechanism**, where `${project.nosnapshot.version}` is a placeholder that gets replaced with an actual value during the Maven build process. The `project.nosnapshot.version` appears to be a **custom property** that's likely defined elsewhere in the project's POM (Project Object Model) file or inherited from a parent POM.

The name `nosnapshot.version` suggests this property contains a **release version number without the "-SNAPSHOT" suffix**. In Maven, snapshot versions (like "1.0.0-SNAPSHOT") indicate development versions, while release versions (like "1.0.0") indicate stable, published versions. This property is commonly used when you need to reference a clean version number for documentation, deployment descriptors, or plugin configurations where snapshot suffixes might cause issues.

**Key gotcha**: If the `project.nosnapshot.version` property isn't properly defined in your POM file, Maven will leave the placeholder as literal text rather than substituting it with a value. This could result in your `plugin.xml` containing the raw string `${project.nosnapshot.version}` instead of an actual version number, potentially breaking your application or deployment process.

This pattern is particularly useful in **multi-module Maven projects** where you want consistent versioning across all modules while maintaining the flexibility to strip snapshot indicators when needed for production builds or plugin manifests.

---

_**User (2025-09-24 05:45Z)**_

@workspace /explain 

---

_**Assistant (copilot/claude-sonnet-4)**_

The code snippet `<library name="lib/${project.build.finalName}.jar" />` is an XML element that defines a **library dependency** within the plugin's runtime configuration. This element is part of the plugin descriptor format used by the Oxygen XML Author framework.

The `name` attribute specifies the **path to the JAR file** that contains the compiled Java classes for this plugin. The path uses Maven's **property substitution mechanism** with `${project.build.finalName}`, which is a built-in Maven property that resolves to the final name of the project's primary artifact. By default, this property combines the project's `artifactId` and `version` (e.g., if your project has artifactId "dila-ai-markup-plugin" and version "0.2.3", the final name would be "dila-ai-markup-plugin-0.2.3").

The complete path `lib/${project.build.finalName}.jar` indicates that the JAR file will be located in a `lib` subdirectory relative to the plugin's installation directory. This is a common Maven convention where compiled artifacts are placed in a lib folder for distribution. When Maven builds the project, it will replace `${project.build.finalName}` with the actual filename, resulting in something like `lib/dila-ai-markup-plugin-0.2.3.jar`.

This approach provides **build-time flexibility** by automatically adjusting the library reference whenever the project version changes, eliminating the need to manually update the `plugin.xml` file for each release. It's particularly valuable in **continuous integration scenarios** where version numbers are dynamically generated or when maintaining multiple versions of the same plugin.

---

_**User (2025-09-24 05:53Z)**_

@workspace /fix are the sub-porm.xml and pom.xml sufficient for maven build?

---

_**Assistant (copilot/gpt-4.1)**_

No, as currently written, your `pom.xml` and `sub-pom.xml` are **not sufficient** for a standard Maven multi-module build. Here’s why:

### Issues

1. **`pom.xml` is not a true parent POM**  
   Your `pom.xml` in the root (`dila-ai-markup-plugin`) is set as `<packaging>pom</packaging>`, but it only declares one module:  
   ```xml
   <modules>
     <module>dila-dama-option</module>
   </modules>
   ```
   However, your actual submodules are `dila-ai-markup-core` and `dila-ai-markup-options`.

2. **`sub-pom.xml` is not recognized by Maven**  
   Maven only recognizes `pom.xml` files for project/module definitions. A file named `sub-pom.xml` will be ignored unless you explicitly reference it via the `-f` flag when running Maven commands, which is non-standard and error-prone.

3. **Module structure mismatch**  
   Your folder structure contains:
   - `dila-ai-markup-core/`
   - `dila-ai-markup-options/`
   But your root `pom.xml` does not list these as modules.

### What you should do

#### 1. Use only one parent POM (`pom.xml`) at the root

- Rename or merge the contents of `sub-pom.xml` into your root `pom.xml`.
- List all modules in the `<modules>` section of the root `pom.xml`:
  ```xml
  <modules>
    <module>dila-ai-markup-core</module>
    <module>dila-ai-markup-options</module>
  </modules>
  ```

#### 2. Remove or merge `sub-pom.xml`

- Delete `sub-pom.xml` or merge its relevant configuration (like the assembly plugin) into the root `pom.xml`.

#### 3. Ensure each submodule has its own `pom.xml`

- Both `dila-ai-markup-core` and `dila-ai-markup-options` should have their own `pom.xml` files.

---

### Example: Corrected root `pom.xml`

````xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>dila.ai</groupId>
  <artifactId>dila-ai-markup-parent</artifactId>
  <version>0.2.3</version>
  <packaging>pom</packaging>
  <modules>
    <module>dila-ai-markup-core</module>
    <module>dila-ai-markup-options</module>
  </modules>
  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-assembly-plugin</artifactId>
        <configuration>
          <descriptors>
            <descriptor>assembly.xml</descriptor>
          </descriptors>
          <finalName>dila-ai-markup-plugin-${project.version}</finalName>
        </configuration>
        <executions>
          <execution>
            <phase>package</phase>
            <goals>
              <goal>single</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>
</project>
````

---

### Summary

- **Only one parent POM** at the root, named `pom.xml`.
- **List all modules** in the `<modules>` section.
- **Remove or merge** `sub-pom.xml`.
- **Each module** must have its own `pom.xml`.

**With this structure, `mvn clean install` at the root will build all modules and assemble your plugin.**

---

_**User (2025-09-24 05:56Z)**_

what file has to prepare before maven build?

---

_**Assistant (copilot/gpt-4.1)**_

Before running a Maven build for your Oxygen plugin project, you should ensure the following files are prepared and correctly configured:

---

### 1. **Root `pom.xml`**
- Located at:  
  `pom.xml`
- Should declare all modules (`dila-ai-markup-core`, `dila-ai-markup-options`) and any build plugins or properties needed.

---

### 2. **Module `pom.xml` Files**
- Each submodule (`dila-ai-markup-core`, `dila-ai-markup-options`) must have its own `pom.xml` in its directory.
- These should have `<parent>` referencing the root POM and their own dependencies/configuration.

---

### 3. **`plugin.xml`**
- Located at:  
  `plugin.xml`
- This is the Oxygen plugin descriptor.  
- Make sure all property placeholders (like `${project.nosnapshot.version}`) are defined or replaced during the build.

---

### 4. **Assembly Descriptor (if packaging with Maven Assembly Plugin)**
- Example:  
  `assemblyComponent.xml`
- Defines how to package resources, JARs, and configuration files into the final plugin ZIP/folder.

---

### 5. **Source Files**
- Java source files in each module’s `src/main/java`
- Resource files (like `dila-ai-markup.js`, translations, etc.) in `src/main/resources`

---

### 6. **Other Required Files**
- Any referenced files in the assembly descriptor (e.g., all JARs, resources, and config files)
- Make sure the `lib/` directory is created by the build process or included in the assembly

---

**Summary Table:**

| File/Folder                | Purpose                                      |
|----------------------------|----------------------------------------------|
| `pom.xml`                  | Maven build configuration (root and modules) |
| `plugin.xml`               | Oxygen plugin descriptor                     |
| `assemblyComponent.xml`    | Assembly/package instructions (if used)      |
| `src/main/java`            | Java source code                             |
| `src/main/resources`       | Resources (JS, XML, translations, etc.)      |
| `lib/`                     | Output JARs (created by build)               |

---

**Tip:**  
If you use property placeholders in `plugin.xml` (like `${project.nosnapshot.version}`), ensure Maven filtering is enabled for this file, or define the property in your POM.

**In summary:**  
You must have a complete and correct `pom.xml` (root and modules), `plugin.xml`, and all source/resources in place before running `mvn clean install` or similar Maven build commands.

---

_**User (2025-09-24 05:57Z)**_

do we need assembly.xml for maven build?

---

_**Assistant (copilot/gpt-4.1)**_

You **only need an `assembly.xml`** (or a similar assembly descriptor file) if you want Maven to package your plugin—including its JARs, resources, and configuration files—into a single distributable ZIP or folder using the Maven Assembly Plugin.

### In your case:
- You have an `assemblyComponent.xml`, which looks like a custom assembly descriptor.
- If your Maven build references this file (for example, in the `<descriptor>` section of the `maven-assembly-plugin` in your POM), then **yes, you need it** for the build to produce the final distributable package.

### If you do not use the Maven Assembly Plugin:
- If you are only building JARs and not packaging them together, you do **not** need an assembly descriptor.

---

**Summary:**  
- If your build process requires packaging everything into a ZIP/folder for Oxygen, you need an assembly descriptor (`assemblyComponent.xml` or `assembly.xml`).
- Make sure your POM references the correct file name in the assembly plugin configuration.

**Tip:**  
You can rename `assemblyComponent.xml` to `assembly.xml` if you want to follow Maven conventions, but the name itself does not matter as long as your POM points to the correct file.

---

_**User (2025-09-24 05:59Z)**_

why does this sample prepare assembly.xml and assemblyComponent.xml?

---

_**Assistant (copilot/gpt-4.1)**_

The sample prepares both `assembly.xml` and `assemblyComponent.xml` because:

- **`assembly.xml`** is the main assembly descriptor used by the Maven Assembly Plugin. It defines the overall packaging format (like `jar` or `zip`) and references one or more component descriptors.
- **`assemblyComponent.xml`** is a component descriptor that specifies exactly which files, directories, and dependencies should be included in the assembled package, and where they should be placed in the output structure.

**How it works:**
- `assembly.xml` tells Maven to use the `assemblyComponent.xml` for detailed file inclusion instructions.
- This separation allows you to reuse the same `assemblyComponent.xml` in different assemblies or formats, and keeps the configuration modular and maintainable.

**In summary:**  
`assembly.xml` defines the packaging and references `assemblyComponent.xml`, which lists the actual files and layout for the plugin package. This is a common Maven pattern for complex or reusable assembly configurations.

---

