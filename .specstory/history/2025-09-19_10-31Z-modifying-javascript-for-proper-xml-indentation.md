<!-- Generated by SpecStory -->

# Modifying JavaScript for Proper XML Indentation (2025-09-19 10:31Z)

_**User (2025-09-19 10:36Z)**_

modify the code to use JavaScript to impose and or save options in avoiding the no indent xml output

---

_**Assistant**_

I'll modify the code to use JavaScript string manipulation for XML generation to ensure proper indentation, avoiding the Java XML transformer's potential formatting issues.

## Step-by-step solution:

1. Replace the Java XML parsing in `importDAMAOptions` with JavaScript string manipulation
2. Replace the Java XML generation in `saveDAMAOptions` with JavaScript string building with proper indentation
3. Use regular expressions for parsing XML content
4. Build XML with proper formatting using JavaScript string concatenation

### [dila-ai-markup.js](file:///c%3A/Project/OCR2Markup/Models/Gemini2.5/dilaAIMarkupPlugin/dila-ai-markup.js)

Replace the XML import/save functions with JavaScript-based implementations that ensure proper XML formatting with indentation.

````javascript
    /**
     * Imports options from an XML file and sets them in the options panel fields.
     * Uses JavaScript string manipulation to parse XML content.
     * @param {java.io.File} optionsFile The XML file containing the options.
     * @param {javax.swing.JTextField} parseModelField The text field for the parse model.
     * @param {javax.swing.JTextField} detectModelField The text field for the detect model.
     * @param {javax.swing.JPasswordField} apiKeyField The password field for the API key.
     */
    function importDAMAOptions(optionsFile, parseModelField, detectModelField, apiKeyField) {
        logDebug("\nimportDAMAOptions");
        if (optionsFile != null && optionsFile.exists()) {
            try {
                // Read file content using Java FileReader
                var FileReader = Packages.java.io.FileReader;
                var BufferedReader = Packages.java.io.BufferedReader;
                
                var fileReader = new FileReader(optionsFile);
                var bufferedReader = new BufferedReader(fileReader);
                var xmlContent = "";
                var line;
                while ((line = bufferedReader.readLine()) != null) {
                    xmlContent += line + "\n";
                }
                bufferedReader.close();
                fileReader.close();
                
                // Parse XML content using JavaScript regex
                var parseModelMatch = xmlContent.match(/<field\s+name="ft\.parse\.model"[^>]*>[\s\S]*?<string[^>]*>([\s\S]*?)<\/string>/);
                if (parseModelMatch) {
                    parseModelField.setText(parseModelMatch[1].trim());
                }
                
                var detectModelMatch = xmlContent.match(/<field\s+name="ft\.detect\.model"[^>]*>[\s\S]*?<string[^>]*>([\s\S]*?)<\/string>/);
                if (detectModelMatch) {
                    detectModelField.setText(detectModelMatch[1].trim());
                }
                
                var apiKeyMatch = xmlContent.match(/<field\s+name="api\.key"[^>]*>[\s\S]*?<string[^>]*>([\s\S]*?)<\/string>/);
                if (apiKeyMatch) {
                    // The API key is stored in Base64 for simple obfuscation. Decode it.
                    // WARNING: This is not true encryption.
                    var Base64 = Packages.java.util.Base64;
                    var encodedValue = apiKeyMatch[1].trim();
                    logDebug("fieldValue: " + encodedValue);
                    var decodedBytes = Base64.getDecoder().decode(encodedValue);
                    logDebug("decodedBytes: " + decodedBytes);
                    apiKeyField.setText(new Packages.java.lang.String(decodedBytes));
                    logDebug("apiKeyField after convert: " + apiKeyField.getText());
                }
                
                logDebug("Successfully imported options from DAMAOptions.xml");
            } catch (e) {
                logDebug("Error importing DAMAOptions.xml: " + e);
            }
        } else {
            logDebug("DAMAOptions.xml not found, using default values.");
        }
    }

    /**
     * Saves the current options to the XML file using JavaScript string building.
     * Ensures proper XML indentation and formatting.
     * @param {java.io.File} optionsFile The XML file to save the options to.
     * @param {javax.swing.JTextField} parseModelField The text field for the parse model.
     * @param {javax.swing.JTextField} detectModelField The text field for the detect model.
     * @param {javax.swing.JPasswordField} apiKeyField The password field for the API key.
     */
    function saveDAMAOptions(optionsFile, parseModelField, detectModelField, apiKeyField) {
        try {
            // Ensure parent directory exists
            var parentDir = optionsFile.getParentFile();
            if (!parentDir.exists()) {
                parentDir.mkdirs();
            }
            logDebug("\nsaveDAMAOptions");

            // Get field values
            var parseModel = parseModelField.getText();
            var detectModel = detectModelField.getText();
            
            // WARNING: Storing API keys, even obfuscated, in a config file is a security risk.
            // Here we use Base64 as a simple deterrent, not as a secure encryption method.
            var Base64 = Packages.java.util.Base64;
            var passwordChars = apiKeyField.getPassword();
            logDebug("class name of passwordChars: " + passwordChars.getClass().getName());
            logDebug("passwordChars: " + passwordChars);
            var javaString = new Packages.java.lang.String(passwordChars);
            var encodedApiKey = Base64.getEncoder().encodeToString(javaString.getBytes("UTF-8"));
            logDebug("encodedApiKey: " + encodedApiKey);

            // Build XML content with proper indentation using JavaScript
            var xmlContent = '<?xml version="1.0" encoding="UTF-8"?>\n' +
                '<serialized version="18.0" xml:space="preserve">\n' +
                '  <map>\n' +
                '    <entry>\n' +
                '      <String>dila.ai.markup.assistant.options</String>\n' +
                '      <dilaAIMarkupAssistantOptions>\n' +
                '        <field name="ft.parse.model">\n' +
                '          <string>' + escapeXml(parseModel) + '</string>\n' +
                '        </field>\n' +
                '        <field name="ft.detect.model">\n' +
                '          <string>' + escapeXml(detectModel) + '</string>\n' +
                '        </field>\n' +
                '        <field name="api.key">\n' +
                '          <string>' + escapeXml(encodedApiKey) + '</string>\n' +
                '        </field>\n' +
                '      </dilaAIMarkupAssistantOptions>\n' +
                '    </entry>\n' +
                '  </map>\n' +
                '</serialized>';

            // Write XML content to file using Java FileWriter
            var FileWriter = Packages.java.io.FileWriter;
            var BufferedWriter = Packages.java.io.BufferedWriter;
            
            var fileWriter = new FileWriter(optionsFile);
            var bufferedWriter = new BufferedWriter(fileWriter);
            bufferedWriter.write(xmlContent);
            bufferedWriter.flush();
            bufferedWriter.close();
            fileWriter.close();

            logDebug("Successfully saved options to DAMAOptions.xml");
            return true;
        } catch (e) {
            logDebug("Error saving DAMAOptions.xml: " + e);
            return false;
        }
    }

    /**
     * Escapes XML special characters in a string.
     * @param {string} str The string to escape.
     * @returns {string} The escaped string.
     */
    function escapeXml(str) {
        if (!str) return "";
        return String(str)
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#39;");
    }

// ...existing code...
````

---

